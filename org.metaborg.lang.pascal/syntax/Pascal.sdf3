module Pascal

context-free start-symbols Program

context-free syntax // Programs and Blocks
  
  Program.Program = <
    <Programheading> 
    <Block>.
  >

  Programheading.ProgramHeading = 
    <program <Identifier> (<{Identifier ","}*>) ;>

  Block.Block = <
    <LabelDeclarations>
    <ConstantDefinitions>
    <TypeDefinitions>
    <VariableDeclarations>
    <ProcedureOrFunctionDeclaration*>
    <Statements>
  >
  
  LabelDeclarations.NoLabelDecls = <>

  LabelDeclarations.LabelDecls =
    <label 
       <{Label ","}*>;>

  ConstantDefinitions.NoConstDefs = <>
  
  ConstantDefinitions.ConstDefs =
    <const 
       <{ConstantDefinition "\n"}*>>

  ConstantDefinition.ConstDef =
    <<Identifier> = <Constant>;>

  TypeDefinitions.NoTypeDefs = <>
  
  TypeDefinitions.TypeDefs =
    <type 
       <{TypeDefinition "\n"}*>>

  TypeDefinition.TypeDef =
    <<Identifier> = <Type>;>

  VariableDeclarations.NoVarDecls = <>
  
  VariableDeclarations.VarDecls =
    <var 
       <{VariableDeclaration "\n"}*>>

  VariableDeclaration.VarDecl =
    <<{Identifier ","}*> : <Type>;>

context-free syntax // procedure and function declarations

  ProcedureOrFunctionDeclaration.ProcDecl =
    <<ProcedureHeading>;
     <Block>;>
    
  ProcedureOrFunctionDeclaration.ProcDirective =
    <<ProcedureHeading>;
     <Directive>;>
    
  ProcedureOrFunctionDeclaration.ProcId =
    <<ProcedureIdentification>;
     <Block>;>

  ProcedureOrFunctionDeclaration.FuncDecl =
    <<FunctionHeading>; 
     <Block>;>
     
  ProcedureOrFunctionDeclaration.FuncDirective =
    <<FunctionHeading>; 
     <Directive>;>
    
  ProcedureOrFunctionDeclaration.FuncId =
    <<FunctionIdentification>;
     <Block>;>

  Directive.Forward = <forward>
  // Directive = Compilerdefineddirectives
  
  Statements.Statements = <
    begin  
      <{Statement ";"}+>
    end
  >

context-free syntax // Procedure and Function Definitions

  ProcedureHeading.ProcHeading =
    <procedure <Identifier> <FormalParameters>>
    
  FunctionHeading.FuncHeading =
    <function <Identifier> <FormalParameters> : <ResultType>>

  ResultType = TypeIdentifier

  ProcedureIdentification.ProcId =
    <procedure <Identifier>>

  FunctionIdentification.FuncId =
    <function <Identifier>>

  FormalParameters.NoParams = <>
  
  FormalParameters.Params =
    <(<{FormalParameter ";"}+>)>
    
  FormalParameter.ValueParams =
    <<{Identifier ","}+> : <ParameterType>>

  FormalParameter.VarParams =
    <var <{Identifier ","}+> : <ParameterType>>

  FormalParameter = ProcedureHeading
  FormalParameter = FunctionHeading

  ParameterType = TypeIdentifier 
  ParameterType = ConformantArraySchema

  ConformantArraySchema = PackedConformantArraySchema 
  ConformantArraySchema = UnpackedConformantArraySchema

  PackedConformantArraySchema.PackedArray = 
    <packed array [<Boundspecification>] of <TypeIdentifier>>

  UnpackedConformantArraySchema.UnpackedArray =
    <array [<{Boundspecification ";"}+>] of <ArrayType>>
    
  ArrayType = TypeIdentifier 
  ArrayType = ConformantArraySchema

  Boundspecification.BoundSpec =
    <<Identifier> .. <Identifier> : <Ordinaltypeidentifier>>

  Ordinaltypeidentifier = TypeIdentifier

context-free syntax // Statements

  //Statementsequence.Seq = <<{Statement ";"}+>>
  
  //Statement.NoOp = <> 
  // to model optional ; at end of statement sequence
  // not clear that the standard includes that
  
  Statement.Labeled =
    <<Label> : <Stat>>
    
  Statement = Stat
    
  Stat = Simplestatement 
  Stat = Structuredstatement
      
  Simplestatement = Assignmentstatement 
  Simplestatement = Procedurestatement  
  Simplestatement = Gotostatement 

  Assignmentstatement.Assign =
    <<Variable> := <Expression>>

//  LValue = Variable 
//  LValue = Functionidentifier

  Procedurestatement.ProcCall =
    <<Identifier> <Actualparameterlist>>
    
  Gotostatement.Goto =
    <goto <Label>>
    
  Structuredstatement = Compoundstatement 
  Structuredstatement = Repetitivestatement 
  Structuredstatement = Conditionalstatement 
  Structuredstatement = Withstatement
  
  Compoundstatement.Compound = <
    begin 
      <{Statement ";"}+> 
    end
  >
  
  Repetitivestatement = Whilestatement 
  Repetitivestatement = Repeatstatement 
  Repetitivestatement = Forstatement
  
  Whilestatement.While = <
    while <Expression> do 
      <Statement>
  >
  
  Repeatstatement.Repeat = <
    repeat 
      <{Statement ";"}+> 
    until <Expression>
  >
  
  Forstatement.For = <
    for <Variableidentifier> := <Initialexpression> <UpDown> <Finalexpression> do 
      <Statement>
  >
  
  UpDown.Up = <to>
  UpDown.Down = <downto>
  
  Initialexpression = Expression
  Finalexpression = Expression

  Conditionalstatement = Ifstatement 
  Conditionalstatement = Casestatement

  Ifstatement.If = <
    if <Expression> then 
      <Statement>
  >
  Ifstatement.IfElse = <
    if <Expression> then 
      <Statement>
    else 
      <Statement>
  >
  
  Casestatement.Case = <
    case <Expression> of
      <Caselimb+>
    end
  >
  
  Caselimb.CaseLimb = 
    <<{Constant ","}+> : <Statement>;>

//  Caselabellist = {Constant ","}+

  Withstatement.With = <
    with <{Variable ","}+> do
      <Statement>
  >
  
  Actualparameterlist.Params = <
    (<{Expression ","}*>)
  >
  
//  Actualparameter = Actualvalue 
//  Actualparameter = Actualvariable 
//  Actualparameter = Actualprocedure 
//  Actualparameter = Actualfunction
//  Actualvalue     = Expression
//  Actualprocedure = Procedureidentifier
//  Actualfunction  = Functionidentifier

context-free syntax // Expressions
  
  Expression.Sign  = <<Sign> <Expression>>
  Expression.RelOp = <<Expression> <Relationaloperator> <Expression>>  
  Expression.AddOp = <<Expression> <Additionoperator> <Expression>>
  
  Expression.MulOp = <<Expression> <Multiplicationoperator> <Expression>>
  
context-free priorities

  Expression.Sign > Expression.MulOp > Expression.AddOp > Expression.RelOp,
  
  Expression.Not > Expression.RelOp
  
context-free syntax

  Expression = Variable
  Expression = Number
  Expression = String
  Expression = Set
  Expression.NilE = <nil>
//  Expression = Constantidentifier
//  Expression = Boundidentifier
  Expression = Functiondesignator
  Expression = <(<Expression>)> {bracket}
  Expression.Not = <not <Expression>>

  Relationaloperator.Eq  = [=] 
  Relationaloperator.NEQ = [<>] 
  Relationaloperator.LT  = [<]
  Relationaloperator.LEQ = [<=] 
  Relationaloperator.GT  = [>]
  Relationaloperator.GEQ = [>=] 
  Relationaloperator.IN  = <in>
  
  Additionoperator.ADD = <+>
  Additionoperator.MIN = <-> 
  Additionoperator.OR = <or>

  Multiplicationoperator.MUL = <*>
  Multiplicationoperator.DIV = </>
  Multiplicationoperator.IDIV = <div>
  Multiplicationoperator.MOD = <mod>
  Multiplicationoperator.AND = <and>

  Variable.Ref = Identifier
//  Variable = Entirevariable 
  Variable = Componentvariable 
  Variable = Referencedvariable
  
//  Entirevariable = Variableidentifier
//  Entirevariable = Fieldidentifier

  Componentvariable = Indexedvariable 
  Componentvariable = Fielddesignator
  Componentvariable = Filebuffer

  Indexedvariable.IndexVar = 
    <<Variable> [<{Expression ","}*>]>
    
  Fielddesignator.FieldAccess =
    <<Variable>.<FieldIdentifier>>
  
  Set.Set = <[<{Expression ","}*>]>

  Functiondesignator.FunCall = 
    <<Identifier><Actualparameterlist>>
    
  Filebuffer.FileVar = 
    <<Variable>^>

context-free syntax // Types

  Type = Simpletype 
  Type = Structuredtype 
  Type = Pointertype 
  Type = TypeIdentifier

  Simpletype = Subrangetype 
  Simpletype = Enumeratedtype
  
  Enumeratedtype.EnumType = <(<{Identifier ","}+>)>
  
  Subrangetype.SubrangeType =
    <<Lowerbound> .. <Upperbound>>
    
  Lowerbound = Constant
  Upperbound = Constant

  Structuredtype = Unpackedstructuredtype
  Structuredtype.Packed = 
    <packed <Unpackedstructuredtype>>
    
  Unpackedstructuredtype = Arraytype 
  Unpackedstructuredtype = Recordtype 
  Unpackedstructuredtype = Settype 
  Unpackedstructuredtype = Filetype
  
  Arraytype.ArrayType = 
    <array [<{Indextype ","}+>] of <Elementtype>>
    
  Indextype = Simpletype
  Elementtype = Type

  Recordtype.RecordType = <
    record  
      <Fieldlist>
    end
  >

  Settype.SetType = 
    <set of <Basetype>>
    
  Basetype = Type

  Filetype.FileType = 
    <file of <Filecomponenttype>>
    
  Filecomponenttype = Type

  Pointertype.PointerType = 
    <^ <TypeIdentifier>>

context-free syntax // Record Fields

  Fieldlist.Fields = <<Recordsection*> <Variantpart>>

  Recordsection.Fields =
    <<{Identifier ","}+> : <Type>;>

  Variantpart.Variant = <
    case <Tagfield?> <TypeIdentifier> of 
      <{Variant ";"}+>;
  >

  Tagfield.Tag = <<Identifier> :>

  Variant.Variant = 
    <<{Constant ","}+> : (<Fieldlist>)>

context-free syntax // Input/Output

//  Outputlist = {Outputvalue ","}+
  
//  Outputvalue = <<Expression> ; <Fieldwidth> : <Fractionlength>>
//  Outputvalue = <<Expression> ; <Fieldwidth>>
//  Outputvalue = Expression
  
  Fieldwidth = Expression
  Fractionlength = Expression

lexical syntax // Variable and Identifier Categories

  Identifier = [a-zA-Z][a-zA-Z0-9]*
  
lexical restrictions

  Identifier -/- [a-zA-Z0-9]
  
context-free syntax

  Referencedvariable.RefVar  = <<Variable>^>
  
//  Filevariable        = Variable
//  Recordvariable      = Variable
//  Pointervariable     = Variable
//  Actualvariable      = Variable
//  Arrayvariable       = Variable
  
  TypeIdentifier.TypeId = Identifier
  
  FieldIdentifier.FieldId     = Identifier
  ConstantIdentifier.ConstantId  = Identifier
  
  Variableidentifier.VarId  = Identifier
  
//  Procedureidentifier.ProcId = Identifier
//  Functionidentifier.FuncId  = Identifier
  
  Boundidentifier.BoundId     = Identifier

context-free syntax // Low Level Definitions
 
  Label.Label = Integernumber
  
  Constant.ConstId     = Sign? ConstantIdentifier 
  Constant.ConstNum    = Number
  Constant.ConstString = String
   
  Number.Int  = Integernumber 
  Number.Real = Realnumber
  
  Sign.Pos = <+>
  Sign.Neg = <->
  
lexical syntax // Numbers
  
  Integernumber = Digitsequence
  Realnumber    = Digitsequence "." Digitsequence? Scalefactor?
  Realnumber    = Digitsequence Scalefactor
  Scalefactor   = [Ee] [\+\-]? Digitsequence

  Unsigneddigitsequence = [0-9]+
  Digitsequence = [\+\-]? Unsigneddigitsequence

lexical restrictions

  Integernumber -/- [0-9]
  Realnumber -/- [0-9]
  
lexical syntax // Strings

  String = "'" Stringcharacter+  "'"
  Stringcharacter = ~[\'] 
  Stringcharacter = "''"

lexical syntax // layout
  
  LAYOUT         = [\ \t\n\r] // whitespace
  LAYOUT         = Comment
  Comment        = "{" InsideComment* "}" 
  InsideComment  = ~[\}] 
  InsideComment  = Comment // nested comment, not in standard

context-free restrictions

  LAYOUT? -/- [\ \t\n\r\{]
